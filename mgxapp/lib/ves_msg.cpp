// vi: ts=4 sw=4 noet:
/*
==================================================================================
    Copyright (c) 2020 AT&T Intellectual Property.
    Copyright (c) 2020 Nokia

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
==================================================================================
*/

/*
    Mnemonic:	ves_msg.cpp
    Abstract:	Functions related to building a ves message payload (json).
				The curl interface functions also live here as VES is the
				only real need to send any data via mule.

    Date:       16 June 2020
    Author:     E. Scott Daniels
*/

#include <memory>
#include <sstream>

#include "ricxfcpp/jhash.hpp"

#include <curlpp/cURLpp.hpp>
#include <curlpp/Easy.hpp>
#include <curlpp/Options.hpp>
#include <curlpp/Exception.hpp>


#include "tools.h"
#include "ves_msg.h"

namespace munchkin {

// ---- private things to help the ves functions -----------------------------------

/*
	Return the type of the json value.
*/
static int get_jtype(  std::shared_ptr<xapp::Jhash> jh, const char* name ) {
	if( jh->Is_string( (char *) "value" ) ) {
		return JT_STRING;
	}

	if( jh->Is_value( (char *) "value"  ) ) {
		return JT_VALUE;
	}

	if( jh->Is_bool( (char *) "value"  ) ) {
		return JT_BOOL;
	}

	return JT_NIL;
}


munchkin::Ves_sender::Ves_sender( std::string ves_url ) :
	url( ves_url )
{ /* empty body */ }

munchkin::Ves_sender::~Ves_sender() {
		// nothing to do
}

/*
	Accept event json generated by event_build() and send it via curl. The result
	is a simple success or failure.
*/
bool munchkin::Ves_sender::Send_event( const std::string& event ) {
	curlpp::Easy req;
	std::list<std::string> header;
	std::ostringstream resp;
	bool	ok = true;

	try {								// it would be nice if we could avoid t/c gook as it's horrible for problem isolation
		req.setOpt( new curlpp::options::Url( url ) );
		req.setOpt( new curlpp::options::Verbose( false ) );

		header.push_back( "Content-Type: application/json" );
		req.setOpt( new curlpp::options::HttpHeader( header ) );

		req.setOpt( new curlpp::options::ConnectTimeout( 2 ) );

		req.setOpt( new curlpp::options::PostFields( event ) );
		req.setOpt( new curlpp::options::PostFieldSize( event.length() ) );

		req.setOpt( new curlpp::options::WriteStream( &resp ) );

		req.perform();

	}	catch( curlpp::LogicError& e ) {
			mt_log( MT_LOG_ERR, (char *) "curl logic error: %s\n", e.what() );
			ok = false;
		}
		catch( curlpp::RuntimeError& e ) {
			mt_log( MT_LOG_ERR, (char *) "curl runtime error: %s\n", e.what() );
			ok = false;
		}

	return ok;
}


// ---------- public things ---------------------------------------------------------

/*
	Given a remote thing, and message related information, build an event header.
	This returns a stirng with a named object and assumes it is not the last
	object in the overall json (is tailed with a comma).

		Common Event Header
		See https://git.opnfv.org/ves/tree/tests/docs/ves_data_model.json
		for an up to date schema, but this is the gyst:

			"commonEventHeader": {
				"domain": "measurement",
				"eventId": "Measurements0000000013",
				"eventName": "Mvfs_ricp_Measurements",
				"lastEpochMicrosec": 1584546360000000,
				"nfNamingCode": "ricp",
				"priority": "Normal",
				"reportingEntityId": "035EEB88-7BA2-4C23-A349-3B6696F0E2C4",
				"reportingEntityName": "Vespa",
				"sequence": 0,
				"sourceName": "'10.244.0.11:8080'",
				"startEpochMicrosec": 1584546330000000,
				"version": 3
			},

			"domain":  enum-string
				"fault" | "heartbeat" | "measurementsForVfScaling" | "mobileFlow" | "other" | "sipSignaling" |
				"stateChange" | "syslog" | "thresholdCrossingAlert" | "voiceQuality"

			"eventId":				string, key unique to the sending source
			"eventName":			string, unique event name
			"eventType":			string, <user defined?> (not error, crit, warn etc)
			"internalHeaderFields": <who knows>
			"lastEpochMicrosec":	microsecond timestamp, event time
			"nfcNamingCode":		string, 3 char, component type from vfc naming standards?
			"nfNamingCode":			string, 4 char, network function type vnf naming standards?
			"priority":				enum-string, "High" | "Medium" | "Normal" | "Low"
			"reportingEntityId":	string,  component reporting the event, a UUID generated by AT&T "enrichment process"?
			"reportingEntityName":	string, reporting name; can be same as source name
			"sequence":				integer, 0 if not needed else sender's sequence number
			"sourceId":				string, component to which event applies, enrichment generated UUID
			"sourceName":			string - name of the affected component
			"startEpochMicrosec":	microsecond timestamp of first related event
			"version"				value, version of the event header

		These fields are required:
			"domain",
			"eventId",
			"eventName",
			"lastEpochMicrosec",
            "priority",
			"reportingEntityName",
			"sequence",
			"sourceName",
			"startEpochMicrosec",
			"version"

*/
std::string eh_build( std::shared_ptr<Rthing> rt, long long ts, std::string reporter, std::string affected ) {
	char	wbuf[4096];

	wbuf[0] = 0;
	json_start_obj( wbuf, sizeof( wbuf ), EH_OBJ_TAG );

	json_add_string( wbuf, sizeof( wbuf ), EH_DOMAIN, (char *) "measurement", MT_NO_FLAGS );
	json_add_string( wbuf, sizeof( wbuf ), EH_ID, rt->Get_eid().c_str(), MT_NO_FLAGS );
	json_add_string( wbuf, sizeof( wbuf ), EH_NAME, (char *) "stats_measurements", MT_NO_FLAGS );
	// not required: json_add_string( wbuf, sizeof( wbuf ), EH_TYPE, (char *) "stats_measurements", MT_NO_FLAGS );

	json_add_ll( wbuf, sizeof( wbuf ), EH_ETIME, ts, MT_NO_FLAGS );
	json_add_ll( wbuf, sizeof( wbuf ), EH_START, rt->Get_created(), MT_NO_FLAGS );

	json_add_string( wbuf, sizeof( wbuf ), EH_PRIORITY, (char *) "normal", MT_NO_FLAGS );
	// not required: json_add_string( wbuf, sizeof( wbuf ), EH_RPTID, (char *) "xxx-yyy-zzz", MT_NO_FLAGS );
	json_add_string( wbuf, sizeof( wbuf ), EH_RPTNM, (char *) reporter.c_str(), MT_NO_FLAGS );

	// not required: json_add_string( wbuf, sizeof( wbuf ), EH_SRCID, (char *) "aaa-bbb-ccc", MT_NO_FLAGS );
	json_add_string( wbuf, sizeof( wbuf ), EH_SRCNM, (char *) affected.c_str(), MT_NO_FLAGS );

	json_add_int( wbuf, sizeof( wbuf ), EH_SEQ, 0, MT_NO_FLAGS );

	json_add_int( wbuf, sizeof( wbuf ), EH_VER, EH_VERSION_VAL, MT_FL_CLOSE );

	mt_log( MT_LOG_DEBUG, (char *) "built header: %s\n", wbuf );
	return std::string( wbuf );
}

/*
	Measurement field builder. Returns a named object of the form:

		"measurementFields": {
			"additionalFields": {
				"SgNB Request Rate": "100",
				"SgNB Accept Rate": "10"
			}, "
			measurementInterval": 60,
			"measurementFieldsVersion": "4.0"
		}

	It does seem that even real/integer values are quoted (really?).  What a pain.

	Input is a xAPP framework json hash which must have a "data" array at the root
	level. Each element in the array is assumed to be a json blob with at least
	"name", "type", and "value" fields. Delta is the time delta in mu-seconds.

*/
std::string mf_build( std::shared_ptr<xapp::Jhash> jh, long long delta, bool is_last ) {
	char	jbuf[ 4096];				// json buffer
	char	vbuf[128];					// conversion of a value to string
	int		i;
	int		len;						// data array length
	double	val;
	int		flags = MT_NO_FLAGS;

	jbuf[0] = 0;

	if( (len = jh->Array_len( (char *) "data" )) <= 0 ) {
		mt_log( MT_LOG_WARN, (char *) "field builder: no data found in json ((len=%d)\n", len );
		return std::string( jbuf );							// don't generate an empty object when data missing
	}

	json_start_obj( jbuf, sizeof( jbuf ), MF_OBJ_TAG );		// open the main object
	json_start_obj( jbuf, sizeof( jbuf ), MF_AF_TAG );		// open additional fields

	for( i = 0; i < len; i++ ) {							// add each k/v pair from data
		if( i == len - 1 ) {								// set close for the last one
			flags = MT_FL_CLOSE;
		}

		jh->Unset_blob();												// ensure we are at the root
		if( ! jh->Set_blob_ele( (char *) "data", i ) ) {				// select next data element
			mt_log( MT_LOG_WARN, (char *) "field builder: unable to suss data[%d]", i );
			continue;
		}

		auto name = jh->String( (char *) "id" );			// extract name from it
		mt_log( MT_LOG_DEBUG, (char *) "field builder: adding field [%d] %s", i, name.c_str() );
		if( ! name.empty() ) {
			switch( get_jtype( jh, (char *) "value" ) ) {
				case JT_VALUE:
					// for now we always write doubles; we could check "vtype" and use that to write int if needed
					snprintf( vbuf, sizeof( vbuf ), "%.3f", jh->Value( (char *) "value" ) );		// convert to string to quote in output
					json_add_string( jbuf, sizeof( jbuf ), name.c_str(), vbuf, flags );
					break;

				case JT_STRING:
					json_add_string( jbuf, sizeof( jbuf ), name.c_str(), jh->String( (char *) "value" ).c_str(), flags );
					break;

				case JT_BOOL:
					json_add_bool( jbuf, sizeof( jbuf ), name.c_str(), jh->Bool( (char *) "value" ), flags );
					break;

				default:
					json_add_nil( jbuf, sizeof( jbuf ), name.c_str(), flags );
					break;
			}
		} else {
			mt_log( MT_LOG_WARN, (char *) "field builder: missing ID from field [%d]", i );
			if( flags & MT_FL_CLOSE ) {										// if closing we must add a nil field
				json_add_nil( jbuf, sizeof( jbuf ), (char *) "unknown_id", flags );
			}
		}
	}
	jh->Unset_blob( );			// ensure we leave it back at the root

	json_add_ll( jbuf, sizeof( jbuf ), MF_DELTA_TAG,  delta, MT_NO_FLAGS );

	flags = is_last ?  MT_FL_LAST | MT_FL_CLOSE : MT_FL_CLOSE;
	json_add_string( jbuf, sizeof( jbuf ), MF_VER_TAG, MF_VERSION_VAL, flags );

	mt_log( MT_LOG_DEBUG, (char *) "field builder: final json `%s`", jbuf );
	return std::string( jbuf );
}

/*
	Build an event (the root of all evil). This will build a common event header, add in
	the measurement fields and return the resulting string of json/
	event header is rquired.

	The schema at https://git.opnfv.org/ves/tree/tests/docs/ves_data_model.json does NOT
	list measurement fields which MC produces and we assume we can use.

	From the schema, this could have all of this goop; only the header is required:

		"event": {
            "commonEventHeader": { "$ref": "#/definitions/commonEventHeader" },
            "faultFields": { "$ref": "#/definitions/faultFields" },
            "heartbeatFields": { "$ref": "#/definitions/heartbeatFields" },
            "measurementsForVfScalingFields": { "$ref": "#/definitions/measurementsForVfScalingFields" },
			"mobileFlowFields": { "$ref": "#/definitions/mobileFlowFields" },
            "otherFields": { "$ref": "#/definitions/otherFields" },
            "sipSignalingFields": { "$ref": "#/definitions/sipSignalingFields" },
            "stateChangeFields": { "$ref": "#/definitions/stateChangeFields" },
			"syslogFields": { "$ref": "#/definitions/syslogFields" },
            "thresholdCrossingAlertFields": { "$ref": "#/definitions/thresholdCrossingAlertFields" },
            "voiceQualityFields": { "$ref": "#/definitions/voiceQualityFields" }
          },

*/
std::string event_build( std::shared_ptr<xapp::Jhash> jh, std::shared_ptr<Rthing> rt,
	long long ts, long long delta, std::string reporter, std::string affected ) {
	std::string header;
	std::string mfields;

	header = eh_build( rt, ts, reporter, affected );
	mfields = mf_build( jh,  delta, true );

	return "{  \"event\": { " +  header + mfields + "} }";
}

} // namespace
